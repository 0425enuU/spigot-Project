From d56db82cd2978a74349685a4a392da310f9822df Mon Sep 17 00:00:00 2001
From: md_5 <git@md-5.net>
Date: Tue, 28 Jan 2014 20:32:07 +1100
Subject: [PATCH] Implement Threaded Bulk Chunk Compression and Caching


diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 9b853a9..295b80d 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -228,7 +228,10 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
             }
 
             if (!arraylist.isEmpty()) {
-                this.playerConnection.sendPacket(new PacketPlayOutMapChunkBulk(arraylist));
+                // Spigot Start
+                java.util.Collections.sort( arraylist, new PlayerChunkMap.ChunkComparator( this ) );
+                org.spigotmc.ChunkCompressor.sendAndCompress( this, new PacketPlayOutMapChunkBulk( arraylist ) );
+                // Spigot End
                 Iterator iterator2 = arraylist1.iterator();
 
                 while (iterator2.hasNext()) {
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
index fc92026..484d727 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
@@ -12,9 +12,9 @@ public class PacketPlayOutMapChunkBulk extends Packet {
     private int[] b;
     private int[] c;
     private int[] d;
-    private byte[] buffer;
-    private byte[][] inflatedBuffers;
-    private int size;
+    public byte[] buffer; // Spigot
+    public byte[][] inflatedBuffers; // Spigot
+    public int size; // Spigot
     private boolean h;
     private byte[] buildBuffer = new byte[0]; // CraftBukkit - remove static
     // CraftBukkit start
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index ae4ca63..962e902 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -279,8 +279,27 @@ public class PlayerChunkMap {
         return playermanager.d;
     }
 
+    // Spigot Start
+    public static class ChunkComparator implements java.util.Comparator<Chunk>
+    {
+
+        private final ChunkCoordComparator base;
+
+        public ChunkComparator(EntityPlayer player)
+        {
+            this.base = new ChunkCoordComparator( player );
+        }
+
+        @Override
+        public int compare(Chunk o1, Chunk o2)
+        {
+            return base.compare( o1.l(), o2.l() );
+        }
+
+    }
     // CraftBukkit start - Sorter to load nearby chunks first
-    private static class ChunkCoordComparator implements java.util.Comparator<ChunkCoordIntPair> {
+    public static class ChunkCoordComparator implements java.util.Comparator<ChunkCoordIntPair> {
+        // Spigot End
         private int x;
         private int z;
 
diff --git a/src/main/java/org/spigotmc/ChunkCompressor.java b/src/main/java/org/spigotmc/ChunkCompressor.java
new file mode 100644
index 0000000..d43e528
--- /dev/null
+++ b/src/main/java/org/spigotmc/ChunkCompressor.java
@@ -0,0 +1,80 @@
+package org.spigotmc;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.logging.Level;
+import java.util.zip.CRC32;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.PacketPlayOutMapChunkBulk;
+import net.minecraft.util.io.netty.util.concurrent.DefaultEventExecutorGroup;
+import net.minecraft.util.io.netty.util.concurrent.EventExecutorGroup;
+import org.bukkit.Bukkit;
+
+public class ChunkCompressor
+{
+
+    private static final EventExecutorGroup threadPool = new DefaultEventExecutorGroup( SpigotConfig.compressionThreads, new ThreadFactoryBuilder().setNameFormat( "Chunk Compressor #%d" ).setDaemon( true ).build() );
+    private static final LinkedHashMap<Long, byte[]> cache = new LinkedHashMap<Long, byte[]>( 16, 0.75f, true ); // Defaults, order by access
+    private static volatile int cacheSize;
+
+    public static void sendAndCompress(final EntityPlayer player, final PacketPlayOutMapChunkBulk chunk)
+    {
+        threadPool.submit( new Runnable()
+        {
+
+            @Override
+            public void run()
+            {
+                try
+                {
+                    long start = System.currentTimeMillis();
+                    boolean cached = false;
+                    // Well shit, orebfuscator is at it again
+                    if ( chunk.inflatedBuffers == null )
+                    {
+                        Bukkit.getServer().getLogger().warning( "chunk.inflatedBuffers is null. Are you running Oreobfuscator? If so, please note that it is unsupported and will disable async compression" );
+                        player.playerConnection.sendPacket( chunk );
+                        return;
+                    }
+
+                    // Here we assign a hash to the chunk based on its contents. CRC32 is fast and sufficient for use here.
+                    CRC32 crc = new CRC32();
+                    for ( byte[] c : chunk.inflatedBuffers )
+                    {
+                        crc.update( c );
+                    }
+                    long hash = crc.getValue();
+
+                    byte[] deflated = cache.get( hash );
+                    if ( deflated != null )
+                    {
+                        chunk.buffer = deflated;
+                        chunk.size = deflated.length;
+                        cached = true;
+                    } else
+                    {
+                        chunk.compress(); // Compress the chunk
+                        byte[] buffer = Arrays.copyOf( chunk.buffer, chunk.size ); // Resize the array to correct sizing
+
+                        Iterator<byte[]> iter = cache.values().iterator(); // Grab a single iterator reference
+                        // Whilst this next entry is too big for us, and we have stuff to remove
+                        while ( cacheSize + buffer.length > org.spigotmc.SpigotConfig.chunkCacheBytes && iter.hasNext() )
+                        {
+                            cacheSize -= iter.next().length; // Update size table
+                            iter.remove(); // Remove it alltogether
+                        }
+                        cacheSize += buffer.length; // Update size table
+                        cache.put( hash, buffer ); // Pop the new one in the cache
+                    }
+                    // System.out.println( "Time: " + ( System.currentTimeMillis() - start ) + " " + cached + " " + cacheSize );
+                    player.playerConnection.sendPacket( chunk );
+                } catch ( Throwable t )
+                {
+                    Bukkit.getServer().getLogger().log( Level.WARNING, "Error compressing or caching chunk", t );
+                }
+            }
+        } );
+    }
+}
diff --git a/src/main/java/org/spigotmc/SpigotConfig.java b/src/main/java/org/spigotmc/SpigotConfig.java
index 769ef2a..fb944e7 100755
--- a/src/main/java/org/spigotmc/SpigotConfig.java
+++ b/src/main/java/org/spigotmc/SpigotConfig.java
@@ -266,4 +266,16 @@ public class SpigotConfig
     {
         playerShuffle = getInt( "settings.player-shuffle", 0 );
     }
+
+    public static int compressionThreads = 1; // Stupid unit tests
+    public static int chunkCacheBytes;
+    private static void chunkStuff()
+    {
+        compressionThreads = getInt( "settings.compression-threads", 4 );
+        Bukkit.getLogger().log( Level.INFO, "Using {0} threads for async chunk compression", compressionThreads );
+
+        chunkCacheBytes = getInt( "settings.compressed-chunk-cache", 64 ) << 20;
+        Bukkit.getLogger().log( Level.INFO, "Reserving {0} bytes for compressed chunk cache", chunkCacheBytes );
+
+    }
 }
-- 
1.8.3.2

